<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>My first three.js app</title>
<style>
body { margin: 0; }
</style>
</head>
<body>
<div id="container"></div>
<script type="importmap">
{
    "imports": {
        "three": "./node_modules/three/build/three.module.js"
    }
}
</script>
<script src="./node_modules/three/examples/js/libs/ammo.wasm.js"></script>
<script type="module">
import * as THREE from 'three';
import {OrbitControls} from './node_modules/three/examples/jsm/controls/OrbitControls.js';
import {TransformControls} from './node_modules/three/examples/jsm/controls/TransformControls.js';
import {GLTFLoader} from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';
import {DDSLoader} from './node_modules/three/examples/jsm/loaders/DDSLoader.js';
// import {AmmoPhysics} from './node_modules/three/examples/jsm/physics/AmmoPhysics.js';
import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';
import {
    AmbientLight, // 環境光源
    DirectionalLight, // 平行光源
    HemisphereLight, // 半球光源
    PointLight, // 点光源
    SpotLight // スポットライト光源
} from 'three';

window.Ammo = await Ammo();

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias: true});
const clock = new THREE.Clock();

renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
// renderer.setClearColor(0x000000, 1);
document.body.appendChild(renderer.domElement);

// #Helper
scene.add(new THREE.GridHelper(100, 10));

const _OrbitControls = new OrbitControls(camera, renderer.domElement);
// _OrbitControls.update();

// #Stats
const stats = new Stats();
document.body.appendChild(stats.domElement);

const lights = [];
lights[0] = new PointLight(0xffffff, 0.5, 0);
lights[1] = new PointLight(0xffffff, 0.5, 0);
lights[2] = new PointLight(0xffffff, 0.5, 0);
lights[0].position.set(0, 200, 0);
lights[1].position.set(100, 200, 100);
lights[2].position.set(- 100, - 200, - 100);
scene.add(lights[0]);
scene.add(lights[1]);
scene.add(lights[2]);

const _TransformControls = new TransformControls(camera, renderer.domElement);
_TransformControls.attach(lights[1]);
_TransformControls.addEventListener('dragging-changed', event => {
    _OrbitControls.enabled = !event.value;
});
scene.add(_TransformControls);

// const plane = new THREE.Mesh(
//     new THREE.PlaneGeometry(50, 50),
//     new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534 })
// ).rotateX(- Math.PI / 2);
// scene.add(plane);

// const sphere = new THREE.Mesh(
//     new THREE.SphereGeometry(5, 64, 32),
//     new THREE.MeshPhongMaterial({ color: 0x621589, emissive: 0x072534 })
// );
// scene.add(sphere);
// sphere.position.set(0, 5, 0);

// Engine Initialize
const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
const physicsWorld = new Ammo.btDiscreteDynamicsWorld(
    new Ammo.btCollisionDispatcher(collisionConfiguration),
    new Ammo.btDbvtBroadphase(),
    new Ammo.btSequentialImpulseConstraintSolver(),
    collisionConfiguration
);
physicsWorld.setGravity(new Ammo.btVector3(0, -100, 0));

const dynamicObjects = [];
const transformAux1 = new Ammo.btTransform();

// Initialize
camera.position.set(0, 100, 100);
camera.lookAt(new THREE.Vector3(0, 0, 0));
window.addEventListener('resize', function () {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('click', function () {
    generateObject();
}, false);
animate();

function animate() {
    let deltaTime = clock.getDelta();

    updatePhysics(deltaTime);
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
    stats.update();
}

function updatePhysics(deltaTime) {
    physicsWorld.stepSimulation(deltaTime, 10);

    for (let i = 0, il = dynamicObjects.length; i < il; i++) {
        const objThree = dynamicObjects[i];
        const objPhys = objThree.userData.physicsBody;
        const ms = objPhys.getMotionState();

        if (ms) {
            ms.getWorldTransform(transformAux1);
            const p = transformAux1.getOrigin();
            const q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
        }
    }
}

function generateGround() {
    let size = new Ammo.btVector3(25, 3, 25);
    let pos = new Ammo.btVector3(0, -3, 0);

    let transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(pos);
    let groundBody = new Ammo.btRigidBody(
        new Ammo.btRigidBodyConstructionInfo(
            0,
            new Ammo.btDefaultMotionState(transform),
            new Ammo.btBoxShape(size),
            new Ammo.btVector3(0, 0, 0)
        )
    );
    groundBody.setRestitution(1);
    groundBody.setFriction(1);
    physicsWorld.addRigidBody(groundBody);

    let ground = new THREE.Mesh(
        new THREE.BoxGeometry(size.x() * 2, size.y() * 2, size.z() * 2),
        new THREE.MeshPhongMaterial({ color: 0x999999, emissive: 0x072534 })
    );
    ground.position.set(pos.x(), pos.y(), pos.z());
    scene.add(ground);
}

generateGround();

let textureLoader = new THREE.TextureLoader();
let crateTexture = textureLoader.load("pirate_coin/textures/lambert1_baseColor.png");

function generateObject() {
    const objectSize = 3;
    const margin = 0.5;

    let radius = 1 + objectSize;
    let height = 1;

    let threeObject = new THREE.Mesh(
        new THREE.CylinderGeometry(radius, radius, height, 32, 1),
        new THREE.MeshPhongMaterial({
            color: Math.floor(Math.random() * (1 << 24)),
            map: crateTexture
        })
    );
    let shape = new Ammo.btCylinderShape(new Ammo.btVector3(radius, height * 0.5, radius));
    shape.setMargin(margin);
    threeObject.position.set(0, 100, 0);

    const mass = objectSize * 5;
    const localInertia = new Ammo.btVector3(0, 0, 0);
    shape.calculateLocalInertia(mass, localInertia);
    const transform = new Ammo.btTransform();
    transform.setIdentity();
    const pos = threeObject.position;
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    const motionState = new Ammo.btDefaultMotionState(transform);

    const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
    const body = new Ammo.btRigidBody(rbInfo);

    // // 加速
    body.setLinearVelocity(new Ammo.btVector3(0, -50, 0));
    // // 反発
    body.setRestitution(0.1);
    // // 摩擦
    body.setFriction(0.4);
    // // 減衰率
    body.setDamping(0, 0.5);
    // 回転制限（1の軸でしか回転しない）
    body.setAngularFactor(new Ammo.btVector3(1, 1, 1));
    // 滑り制限（1の軸でしか動かない。初期値には適用されない）
    body.setLinearFactor(new Ammo.btVector3(1, 1, 1));

    threeObject.userData.physicsBody = body;

    threeObject.receiveShadow = true;
    threeObject.castShadow = true;

    scene.add(threeObject);
    dynamicObjects.push(threeObject);

    physicsWorld.addRigidBody(body);
}
</script>
</body>
</html>